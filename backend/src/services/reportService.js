// Report generation service for PDF and Excel exports
const fs = require('fs');
const path = require('path');
const PDFDocument = require('pdfkit');

/**
 * Generate CSV content from data
 * @param {Array} headers - Column headers
 * @param {Array} data - Data rows
 * @returns {string} - CSV content
 */
function generateCSV(headers, data) {
  // Create header row
  const headerRow = headers.map(header => `"${header}"`).join(',');
  
  // Create data rows
  const dataRows = data.map(row => {
    return headers.map(header => {
      const value = row[header] || '';
      // Escape double quotes and wrap in quotes
      return `"${String(value).replace(/"/g, '""')}"`;
    }).join(',');
  });
  
  // Combine header and data rows
  return [headerRow, ...dataRows].join('\n');
}

/**
 * Generate a simple PDF-like text report
 * @param {string} title - Report title
 * @param {Array} headers - Column headers
 * @param {Array} data - Data rows
 * @param {Object} options - Report options
 * @returns {string} - Text-based report content
 */
function generateTextReport(title, headers, data, options = {}) {
  const { 
    dateFormat = 'YYYY-MM-DD',
    currencySymbol = '₹',
    includeSummary = true
  } = options;
  
  let report = '';
  
  // Add title
  report += `=${title}=\n`;
  report += `Generated on: ${new Date().toLocaleDateString()}\n\n`;
  
  // Add summary if requested
  if (includeSummary) {
    report += `Total Records: ${data.length}\n`;
    report += `Report Period: ${options.startDate ? new Date(options.startDate).toLocaleDateString() : 'All time'} to ${options.endDate ? new Date(options.endDate).toLocaleDateString() : 'Present'}\n\n`;
  }
  
  // Add headers
  const headerRow = headers.map(header => header.padEnd(15)).join(' | ');
  report += headerRow + '\n';
  report += '-'.repeat(headerRow.length) + '\n';
  
  // Add data rows
  data.forEach(row => {
    const dataRow = headers.map(header => {
      let value = row[header] || '';
      
      // Format specific data types
      if (header.toLowerCase().includes('date') && value) {
        value = new Date(value).toLocaleDateString();
      } else if (header.toLowerCase().includes('amount') || header.toLowerCase().includes('total') || header.toLowerCase().includes('price')) {
        value = `${currencySymbol}${parseFloat(value).toFixed(2)}`;
      } else if (typeof value === 'number') {
        value = value.toString();
      }
      
      return value.padEnd(15);
    }).join(' | ');
    
    report += dataRow + '\n';
  });
  
  // Add footer
  report += '\n' + '='.repeat(50) + '\n';
  report += 'Report generated by EggMind AI\n';
  
  return report;
}

/**
 * Export data to CSV format
 * @param {Array} data - Data to export
 * @param {Array} headers - Column headers
 * @param {string} filename - Filename for the export
 * @returns {Object} - Export result with file path and content
 */
function exportToCSV(data, headers, filename) {
  try {
    const csvContent = generateCSV(headers, data);
    const filePath = path.join(__dirname, '..', 'exports', `${filename}.csv`);
    
    // Ensure exports directory exists
    const exportsDir = path.join(__dirname, '..', 'exports');
    if (!fs.existsSync(exportsDir)) {
      fs.mkdirSync(exportsDir, { recursive: true });
    }
    
    // Write file
    fs.writeFileSync(filePath, csvContent);
    
    return {
      success: true,
      filePath: filePath,
      content: csvContent,
      format: 'csv'
    };
  } catch (error) {
    return {
      success: false,
      error: error.message
    };
  }
}

/**
 * Export data to text format (as a simple PDF alternative)
 * @param {string} title - Report title
 * @param {Array} data - Data to export
 * @param {Array} headers - Column headers
 * @param {Object} options - Report options
 * @param {string} filename - Filename for the export
 * @returns {Object} - Export result with file path and content
 */
function exportToText(title, data, headers, options, filename) {
  try {
    const textContent = generateTextReport(title, headers, data, options);
    const filePath = path.join(__dirname, '..', 'exports', `${filename}.txt`);
    
    // Ensure exports directory exists
    const exportsDir = path.join(__dirname, '..', 'exports');
    if (!fs.existsSync(exportsDir)) {
      fs.mkdirSync(exportsDir, { recursive: true });
    }
    
    // Write file
    fs.writeFileSync(filePath, textContent);
    
    return {
      success: true,
      filePath: filePath,
      content: textContent,
      format: 'txt'
    };
  } catch (error) {
    return {
      success: false,
      error: error.message
    };
  }
}

/**
 * Export data to PDF format
 * @param {string} title - Report title
 * @param {Array} data - Data to export
 * @param {Array} headers - Column headers
 * @param {Object} options - Report options
 * @param {string} filename - Filename for the export
 * @returns {Object} - Export result with file path and content
 */
function exportToPDF(title, data, headers, options, filename) {
  try {
    const filePath = path.join(__dirname, '..', 'exports', `${filename}.pdf`);
    
    // Ensure exports directory exists
    const exportsDir = path.join(__dirname, '..', 'exports');
    if (!fs.existsSync(exportsDir)) {
      fs.mkdirSync(exportsDir, { recursive: true });
    }
    
    // Create a document
    const doc = new PDFDocument({
      margin: 50,
      size: 'A4'
    });
    
    // Pipe its output to a file
    const stream = fs.createWriteStream(filePath);
    doc.pipe(stream);
    
    // Add title
    doc.fontSize(18).text(title, { align: 'center' });
    doc.moveDown();
    
    // Add generation date
    doc.fontSize(12).text(`Generated on: ${new Date().toLocaleDateString()}`, { align: 'center' });
    doc.moveDown(2);
    
    // Add report period if provided
    if (options.startDate || options.endDate) {
      const startDateStr = options.startDate ? new Date(options.startDate).toLocaleDateString() : 'All time';
      const endDateStr = options.endDate ? new Date(options.endDate).toLocaleDateString() : 'Present';
      doc.fontSize(12).text(`Report Period: ${startDateStr} to ${endDateStr}`);
      doc.moveDown();
    }
    
    // Add data table
    if (data.length > 0) {
      // Calculate column widths
      const columnWidth = 100;
      const startX = 50;
      let startY = doc.y;
      
      // Draw headers
      doc.fontSize(12).font('Helvetica-Bold');
      headers.forEach((header, i) => {
        doc.text(header, startX + (i * columnWidth), startY, { width: columnWidth, align: 'left' });
      });
      
      // Move to next line
      startY = doc.y + 20;
      doc.moveTo(startX, startY - 10).lineTo(startX + (headers.length * columnWidth), startY - 10).stroke();
      
      // Draw data rows
      doc.fontSize(10).font('Helvetica');
      data.forEach((row, rowIndex) => {
        headers.forEach((header, colIndex) => {
          let value = row[header] || '';
          
          // Format specific data types
          if (header.toLowerCase().includes('date') && value) {
            value = new Date(value).toLocaleDateString();
          } else if (header.toLowerCase().includes('amount') || header.toLowerCase().includes('total') || header.toLowerCase().includes('price')) {
            value = `₹${parseFloat(value).toFixed(2)}`;
          } else if (typeof value === 'number') {
            value = value.toString();
          }
          
          doc.text(value, startX + (colIndex * columnWidth), startY + (rowIndex * 20), { width: columnWidth, align: 'left' });
        });
      });
    } else {
      doc.text('No data available for this report.');
    }
    
    // Add footer
    doc.moveDown(2);
    doc.fontSize(10).text('Report generated by EggMind AI', { align: 'center' });
    
    // Finalize PDF file
    doc.end();
    
    // Wait for the file to be written
    return new Promise((resolve) => {
      stream.on('finish', () => {
        resolve({
          success: true,
          filePath: filePath,
          format: 'pdf'
        });
      });
      
      stream.on('error', (error) => {
        resolve({
          success: false,
          error: error.message
        });
      });
    });
  } catch (error) {
    return {
      success: false,
      error: error.message
    };
  }
}

module.exports = {
  generateCSV,
  generateTextReport,
  exportToCSV,
  exportToText,
  exportToPDF
};